<html>
  <head>
    <title>redbug</title>
  </head>
  <body>
     <h1>redbug</h1>
     <h3>intro</h3>

The erlang tracing (the so-called "trace bifs", 
<a href="http://www.erlang.org/doc/man/erlang.html#trace-3">
erlang:trace/3</a> and 
<a href="http://www.erlang.org/doc/man/erlang.html#trace_pattern-3">
erlang:trace_pattern/3</a>) are insanely powerful. However, they might be a bit hard to get used to.<p>

For example, imagine this problem;<p>

We have a system using 10,000 processes. Due to a bug, someone occasionally sends the atom <tt>true</tt> to an important server process. This eventually causes total system failure. We can not easily load code onto the system since it sits at a customer site.<p>

Here's a piece of code (that can be pasted into the Erlang shell). It will trigger when someone sends <tt>true</tt>, and log the name and current function of the sending and the receiving processes.

<pre><tt>
<span style="color:#f00;">% pulls out process info for a given pid.</span>
Pi = fun (P) -&gt; 
 try 
  {element(2,case process_info(P,registered_name) of 
              [] -&gt; process_info(P,initial_call); 
              R -&gt; R 
             end), 
   element(2,process_info(P,current_function))} 
 catch _:_ -&gt; dead 
 end 
end.

<span style="color:#f00;">% called by Init. receives trace messages, filters, logs the hits.</span>
Loop = fun (G) -&gt; 
  receive {trace,Sender,send,true,Rec} -&gt; io:fwrite("~p -&gt; ~p~n", [Pi(Sender), Pi(Rec)]); 
  _ -&gt; ok end, 
 G(G) 
end.

<span style="color:#f00;">% called by spawn. registers, starts the trace, calls Loop</span>
Init = fun () -&gt; 
  register(trip,self()), 
  erlang:trace(all,true,[send]), 
  Loop(Loop) 
end.
</tt></pre>

We start the tracer;
<pre><tt>1&gt;spawn(Init).</tt></pre>

For clarity, I'll register a name for the shell;

<pre><tt>2&gt;register(luke,self()).
true</tt></pre>

So let's send <tt>true</tt> to ourselves;
<pre><tt>3&gt; self()!true.</tt></pre>

The tracer will print this;
<pre><tt>{luke,{shell,eval_loop,3}} -&gt; {luke,{shell,eval_loop,3}}
</tt></pre>

<tt>luke</tt> (i.e. the shell) sent <tt>true</tt> to himself.<p>

To be neat, I stop the tracer;

<pre><tt>4&gt;exit(whereis(trip),kill).</tt></pre>

The point of the above was to show
<ul>
  <li>the trace bifs have immense power
  <li>a higher-level interface is in order 
</ul>

<h3>dbg</h3>

The standard OTP solution is called dbg. Alas, I must recommend against using this on live systems, since it is way too easy to get it wrong.<p>

Try this for a laugh (it will kill the node).<p>

<pre><tt>5&gt; dbg:tracer(),dbg:p(all,m).</tt></pre>

Another problem with dbg is that it does not lift the level of abstraction enough (from that of the trace bifs).<p>

Things look grim, what to do?<p>

<tt>redbug</tt> aims to be a safe and simple interface to the erlang trace functionality, with some extra features thrown in.<p>

The simplicity comes from exposing only the most useful (i.e. the bits I use often) parts of the API in a concise way.<p>

The safety comes partly from the simplicity, but also from the way the redbug process works.<p>

redbug supervises itself and will kill itself if it deems that it is in danger of overloading the node. It also delays the processing of the trace messages until after the trace is done.<p>

The most interesting extra feature is probably the stack match spec. Answers the eternal question: "Who the * is calling my function with this * argument?"

<h3>interface</h3>

The interface consists of the function <tt>start/2</tt>.

<tt>redbug:start(Trc,Opts)</tt>

<pre><tt>
Trc: list('send'|'receive'|string(RTP))
RTP:  restricted trace pattern
  the RTP has the form: "&lt;mfa&gt; when &lt;guards&gt; -&gt; &lt;actions&gt;"
  where &lt;mfa&gt; can be;
  "mod", "mod:fun", "mod:fun/3" or "mod:fun('_',atom,X)"
  &lt;guard&gt; is something like;
  "X==1" or "is_atom(A)"
  and &lt;action&gt; is;
  "return" and/or "stack" (separated by ";")

  E.g.
  ets:lookup(T,hostname) when is_integer(T) -&gt;stack

Opts: list({Opt,Val})

  general opts:
time         (15000)       stop trace after this many ms
msgs         (10)          stop trace after this many msgs
target       (node())      node to trace on
arity        (false)       print arity instead of arg list
blocking     (false)       block start/2, return a list of messages
procs        (all)         (list of) Erlang process(es)
                           all|pid()|atom(RegName)|{pid,I2,I3}

  print-related opts
max_queue    (5000)        fail if internal queue gets this long
max_msg_size (50000)       fail if seeing a msg this big
buffered     (no)          buffer messages till end of trace
print_calls  (true)        print calls
print_file   (standard_io) print to this file
print_msec   (false)       print milliseconds on timestamps
print_depth  (999999)      formatting depth for "~P"
print_re     ("")          print only strings that match this

  trc file related opts
file         (none)        use a trc file based on this name
file_size    (1)           size of each trc file
file_count   (8)           number of trc files
</tt></pre>

<h3>misc</h3>

The call stack displayed by redbug is really a call return stack; i.e. only functions that will be returned to are shown. This is a feature of the emulator (tail call optimization), and cannot be circumvented in a safe way (as far as I know).<p>

redbug has the idiotic/awesome feature that it can be run from a Unix shell. actually pretty handy if you're working against an embedded system.<p>

<pre><tt>
bash$ redbug shad@mwux005 3000 2 "{erlang,phash}"
16:26:00 &lt;prfTrc&gt; {erlang,phash,[time,16]}
</tt></pre>

  </body>
</html>
