<html>
  <head>
    <title>redbug</title>
  </head>
  <body>
     <h1>redbug</h1>
     <h3>intro</h3>

The erlang tracing (the so-called "trace bifs", 
<a href="http://www.erlang.org/doc/man/erlang.html#trace-3">
erlang:trace/3</a> and 
<a href="http://www.erlang.org/doc/man/erlang.html#trace_pattern-3">
erlang:trace_pattern/3</a>) are insanely powerful. However, they might be a bit hard to get used to.<p>

For example, imagine this problem;<p>

We have a system using 10,000 processes. Due to a bug, someone occasionally sends the atom <tt>true</tt> to an important server process. This eventually causes total system failure. We can not easily load code onto the system since it sits at a customer site.<p>

Here's a piece of code (that can be pasted into the Erlang shell). It will trigger when someone sends <tt>true</tt>, and log the name and current function of the sending and the receiving processes.

<pre><tt>
<span style="color:#f00;">% pulls out process info for a given pid.</span>
Pi = fun (P) -&gt; 
 try 
  {element(2,case process_info(P,registered_name) of 
              [] -&gt; process_info(P,initial_call); 
              R -&gt; R 
             end), 
   element(2,process_info(P,current_function))} 
 catch _:_ -&gt; dead 
 end 
end.

<span style="color:#f00;">% called by Init. receives trace messages, filters, logs the hits.</span>
Loop = fun (G) -&gt; 
  receive {trace,Sender,send,true,Rec} -&gt; io:fwrite("~p -&gt; ~p~n", [Pi(Sender), Pi(Rec)]); 
  _ -&gt; ok end, 
 G(G) 
end.

<span style="color:#f00;">% called by spawn. registers, starts the trace, calls Loop</span>
Init = fun () -&gt; 
  register(trip,self()), 
  erlang:trace(all,true,[send]), 
  Loop(Loop) 
end.
</tt></pre>

We start the tracer;
<pre><tt>
1&gt;spawn(Init).
</tt></pre>

For clarity, I'll register a name for the shell;

<pre><tt>
2&gt;register(luke,self()).
true
</tt></pre>

So let's send <tt>true</tt> to ourselves;
<pre><tt>
3&gt; self()!true.
</tt></pre>

The tracer will print this;
<pre><tt>
{luke,{shell,eval_loop,3}} -&gt; {luke,{shell,eval_loop,3}}
</tt></pre>

<tt>luke</tt> (i.e. the shell) sent <tt>true</tt> to himself.<p>

To be neat, I stop the tracer;

<pre><tt>4&gt;exit(whereis(trip),kill).</tt></pre>

The point of the above was to show
<ul>
  <li>the trace bifs have immense power
  <li>a higher-level interface is in order 
</ul>

<h3>dbg</h3>

The standard OTP solution is called dbg. Alas, I must recommend against using this on live systems, since it is way too easy to get it wrong.<p>

Try this for a laugh (it will kill the node).<p>

<pre><tt>5&gt; dbg:tracer(),dbg:p(all,m).</tt></pre>

Another problem with dbg is that it does not lift the level of abstraction enough (from that of the trace bifs).<p>

Things look grim, what to do?<p>

<tt>redbug</tt> aims to be a safe and simple interface to the erlang trace functionality, with some extra features thrown in.<p>

The simplicity comes from exposing only the most useful (i.e. the bits I use often) parts of the API in a concise way.<p>

The safety comes partly from the simplicity, but also from the way the redbug process works.<p>

redbug supervises itself and will kill itself if it deems that it is in danger of overloading the node. It also delays the processing of the trace messages until after the trace is done.<p>

The most interesting extra feature is probably the stack match spec. Answers the eternal question: "Who the * is calling my function with this * argument?"

<h3>interface</h3>

The interface consists of the function <tt>start/2</tt>.

<tt>redbug:start(Rtp,Opts)</tt>

Trace on <tt>erlang:phash</tt>

<tt>redbug:start("erlang:phash").</tt>

As above, but on erlang:phash/2

<tt>redbug:start(5000,1,{erlang,phash,[{'_','_'}]}).</tt>

As above, but second argument must be 16

<tt>redbug:start(5000,1,{erlang,phash,[{'_',16}]}).</tt>

As above, but show the return value

<tt>redbug:start(5000,2,{erlang,phash,[{'_',16},return]}).</tt>

As above, but show the call stack

<tt>redbug:start(5000,2,{erlang,phash,[{'_',16},stack,return]}).</tt>

The output of the last command looks like this

<tt>
15:59:39 &lt;prfTrc&gt; {erlang,phash,[time,16]}
  {prfTrc,loop,1} 
  {prfTrc,start_trace,3}
  {dict,fetch,2}  
15:59:39 &lt;prfTrc&gt; {erlang,phash,2} -&gt; 6
</tt>

The trigger was erlang:phash(time,16) called in dict:fetch/2 and it returned 6.

<h3>misc</h3>

The call stack displayed by redbug is really a call return stack; i.e. only functions that will be returned to are shown. This is a feature of the emulator (tail call optimization), and cannot be circumvented in a safe way (as far as I know).<p>

redbug has the idiotic/awesome feature that it can be run from a Unix shell. actually pretty handy if you're working against an embedded system.<p>

<pre><tt>
bash$ redbug shad@mwux005 3000 2 "{erlang,phash}"
16:26:00 &lt;prfTrc&gt; {erlang,phash,[time,16]}
</tt></pre>

  </body>
</html>
